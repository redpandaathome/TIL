# 두대의 단절된 컴퓨터가 통신하는 웹(HTTP)은 상태를 저장할 공유된 장치가 없다. : HTTP 프로토콜 - stateless(무상태)

http의 무상태 특성을 극복하고 세션을 유지하기 위해 쿠키 메커니즘을 사용.

다양한 클라이언트에서 쿠키 메커니즘이 동작한다고 보장할 수 없다. 그럼 어떻게 세션 유지?

http 무상태 특성을 그대로 이용. (요청할 때 마다 인증 정보를 제시하고 사용자 식별)

클라이언트는 서버에 요청할 때 마다 Authorization 요청 헤더에 인증 정보를 달아서 보냄
-> 서버는 헤더를 석해서 클라이언트를 식별하고 서비스 제공 (식별 결과는 유지X)

1. http 기본인증
:Authorization 헤더에 아이디:비밀번호를 Base65로 인코딩한 문자열을 보내기

2. http 기본인증의 한계
* id, pwd를 클라이언트 애플리케이션에 저장해야 한다. (매번 사용자에게 요구할 수 X) - 공용기기시 위험
* 사실 plain text다
네트워크 구간에 탈취할 수 있다.(개발자 도구로도 헤더를 볼 수 있다. 누구나 읽을 수...)

# 클라이언트 측에서 1)암호화해서 저장하고 2)HTTPS 프로토콜을 이용하면 해결할 수 있지만 궁극적 해결책은 아님.
- 인터넷과 단절된 인트라넷같은 제한된 환경에서 서비스 보호시에는 효용성이 충분

# JWT인증: Jason Web Token
클라(인증정보)->서버(유효성 확인후 토큰제공!)->클라(토큰저장, authorization 헤더에 토큰보내기->서버(확인))

- 헤더(암호화 알고리즘 이름), payload:본문, signature:서명 형식
* (헤더,본문,서명이 한 쌍이라 하나라도 변조되면 무효화)

* 완벽하진 않다. 토큰요청시 사용자 인증정보를 평문/폼데이터 형태의 `평문`으로 전달해야 하기 때문. - 그래도 http 기본인증보다 낫다. + 보완책 : https

* HTTPS 적용시, 헤더와 본문을 전혀 읽을 수 없다.

* 내용이 노출되는 토큰을 왜 사용할까?
jwt 비밀키를 알지 않는 이상 변조가 불가. -> (시그니처를 비밀키로 검사할 때 변조 여부 알 수 있다.) 즉 내용물이 바뀌었는지 걱정하지 않아도 된다.
(외부에 노출되어도 좋은 정보에 한해서 토큰이 넣어두고 사용할 수 있음
- 이름, 권한 등 ->db조회없이 믿을 수 있음.)

단점: 토큰의 용량이 크다.
랜덤 스트링으로 사용자 정보 매번 조회하는 작업의 비용 : jwt토큰 데이터 비용 비교 해서 선택


*HTTP status code
2XX: 성공
3XX: 리디렉션
4XX: 요청 오류
5XX: 서버 오류 (500 내부 서버 오류, 502 불량 게이트웨이, 503 서비스 사용 불가)